package ida3

import (
	"RedDocMD/decision_tree/parser"
	"RedDocMD/decision_tree/utils"
	"errors"
	"math"
)

func entropyGain(rows []parser.Row, attribute string, data *parser.InputData) (float64, error) {
	originalEntropy := utils.Entropy(rows)
	partitions, err := utils.AttributePartition(data, rows, attribute)
	if err != nil {
		return 0.0, errors.New("Invalid atttribute")
	}
	newTotalEntropy := 0.0
	for _, partitionedRows := range partitions {
		newEntropy := utils.Entropy(partitionedRows)
		newTotalEntropy += float64(len(partitionedRows)) / float64(len(rows)) * newEntropy
	}
	return originalEntropy - newTotalEntropy, nil
}

func containsString(arr []string, elem string) bool {
	for _, val := range arr {
		if elem == val {
			return true
		}
	}
	return false
}

func attributeForMaxEntropyGain(rows []parser.Row, data *parser.InputData) string {
	maxGain := 0.0
	bestAttribute := ""
	for _, attribute := range data.AttributeNames {
		gain, _ := entropyGain(rows, attribute, data)
		if gain >= maxGain {
			maxGain = gain
			bestAttribute = attribute
		}
	}
	return bestAttribute
}

// DecisionTree represents the decision tree generated by IDA3 algorithm
type DecisionTree struct {
	Attribute       string
	ParentAttribute string
	Children        map[string]*DecisionTree // Key values are variant names
	isLeaf          bool
	leafAnswer      bool
}

func newDecisionTree(attribute string, parentAttribute string) *DecisionTree {
	tree := new(DecisionTree)
	tree.Attribute = attribute
	tree.ParentAttribute = parentAttribute
	tree.Children = make(map[string]*DecisionTree)
	tree.isLeaf = false
	return tree
}

const eps float64 = 1e-6

func ida3Internal(rows []parser.Row, data *parser.InputData, tree *DecisionTree) {
	baseEntropy := utils.Entropy(rows)
	if math.Abs(baseEntropy) <= eps {
		tree.isLeaf = true
		tree.leafAnswer = rows[0].Result
	} else {
		bestAttribute := attributeForMaxEntropyGain(rows, data)
		partitionedRows, _ := utils.AttributePartition(data, rows, bestAttribute)
		tree.Attribute = bestAttribute
		for _, variant := range data.AttributesMap[bestAttribute].Values {
			subTree := newDecisionTree("", bestAttribute)
			ida3Internal(partitionedRows[variant], data, subTree)
			tree.Children[variant] = subTree
		}
	}
}

// IDA3 performs the IDA3 algorithm on the data passed and returns a decision tree
func IDA3(data *parser.InputData) *DecisionTree {
	decisionTree := newDecisionTree("", "")
	ida3Internal(data.Rows, data, decisionTree)
	return decisionTree
}
